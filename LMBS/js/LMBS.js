// Generated by RPG Maker.
// Do not edit this file directly.
var $plugins =
[
  {"name":"LMBS","status":true,"description":"","parameters":{}}
];

/*
[Note]
    先頭背景変更
        リビジョンカウント
*/

/**
 *  Battler の属する勢力
 */
LMBS_ForceGroup = {
  Party       : 1,    // 味方サイド
  Troop       : 2,    // 敵サイド
  All         : 255,
};


LMBS_Direction = {
  Left      : -1.0,
  Right     :  1.0,
};

Sprite_Battler.prototype.updatePosition = function() {
  //  this.x = this._battler.transform.tx;
    this.y = 100;
};


//=============================================================================
/**
 *  設定
 *  @class LMBS_Settings
 */
function LMBS_Settings() {
    throw new Error('This is a static class');
}

LMBS_Settings.keySelectTarget = 'shift';  // ターゲット選択ボタン


//=============================================================================
// LMBS_SceneGraph
//=============================================================================

function LMBS_SceneGraph() {
    throw new Error('This is a static class');
}

LMBS_SceneGraph.UNIT_PIXEL_SIZE = 64;

LMBS_SceneGraph._objectList   = [];
LMBS_SceneGraph._physicsBodyList   = [];
LMBS_SceneGraph._visualList   = [];
LMBS_SceneGraph._camera       = null;

LMBS_SceneGraph.initialize = function() {
    this.clear();
}

LMBS_SceneGraph.setup = function(viewportSprite) {
    this.clear();
    this.viewportSprite = viewportSprite;

    this._debugGraphics = new PIXI.Graphics();
    this.viewportSprite.addChild(this._debugGraphics);

    var gravityVertical = -9.8;
    var gravity = new Box2D.Common.Math.b2Vec2(0, gravityVertical);
    this.world = new Box2D.Dynamics.b2World(gravity, false);// trueだと止まったオブジェクトは計算対象からはずすので軽くなる

/*
    var debugDraw = new Box2D.Dynamics.b2DebugDraw();
		debugDraw.SetSprite(document.getElementById("canvas").getContext("2d"));
		debugDraw.SetDrawScale(30.0);
		debugDraw.SetFillAlpha(0.5);
		debugDraw.SetLineThickness(1.0);
		debugDraw.SetFlags(Box2D.Dynamics.b2DebugDraw.e_shapeBit | Box2D.Dynamics.b2DebugDraw.e_jointBit);
		this.world.SetDebugDraw(debugDraw);
    */

    var b = new LMBS_BoxBody(1000, 10, 0);
    b.setPosition(30/2, -5);


    //this.test = new LMBS_BoxBody(100, 10, 1);
    //this.test2 = new LMBS_BoxBody(100, 10, 0);
    //this.test3 = new LMBS_BoxBody(100, 10, 1);
  //  this.test3.setPosition(350, 100);
}

LMBS_SceneGraph.clear = function() {
    this._objectList = [];
    this._physicsBodyList = [];
    this._visualList = [];
    this.camera = new LMBS_Camera();
    this.camera.setPosition(10, 0, -10);
}

LMBS_SceneGraph.getMainCamera = function() {
    return this.camera;
}

LMBS_SceneGraph.addObject = function(obj) {
    this._objectList.push(obj);
}
LMBS_SceneGraph.addVisual = function(obj) {
    this._visualList.push(obj);
}

LMBS_SceneGraph.updateWorld = function() {

    this.world.Step(1 / 60, 10, 10);
    this.world.ClearForces();
    this._objectList.forEach(function(obj){
        obj.onUpdate();
    });

    // 物理オブジェクトのデバッグ描画
    this._debugGraphics.clear();
    this._physicsBodyList.forEach(function(body){
        //body.debugDraw(this.camera, this._debugGraphics);
    }, this);
}

/**
 * カメラの更新。ターゲット選択中等、カメラだけ移動させたいときもあるので、オブジェクトとは分ける。
 */
LMBS_SceneGraph.updateCamera = function() {
  /*
    if (Input.isPressed('pageup')) {
        this.camera.position.x += 0.25;
    }
    if (Input.isPressed('pagedown')) {
        this.camera.position.x -= 0.25;
    }
    if (Input.isPressed('control')) {
        this.camera.position.z -= 0.25;
    }
    if (Input.isPressed('shift')) {
        this.camera.position.z += 0.25;
    }
    */
    this.camera.updateMatrix();

    this._visualList.forEach(function(obj){
        obj.updateCoordinate();
    });
}

//=============================================================================
/**
 *
 * @class LMBS_Camera
 * @constructor
 */
function LMBS_Camera() { this.initialize.apply(this, arguments); }
LMBS_Camera.prototype.constructor = LMBS_Camera;

LMBS_Camera.Mode = {
    TargetTracking      : 0,  // プレイヤーキャラと、ターゲットしているエネミーが画面内に収まるように自動移動する
};

/**
 * constructor
 */
LMBS_Camera.prototype.initialize = function() {
    this._position = new LMBS_Vector3(0, 0, -1000);

    this._positionX = new LMBS_EasingValue(0, LMBS_Easing.easeOutExpo);
    this._positionY = new LMBS_EasingValue(0, LMBS_Easing.easeOutExpo);
    this._positionZ = new LMBS_EasingValue(0, LMBS_Easing.easeOutExpo);

    this.viewMatrix = new LMBS_Matrix();
    this.projMatrix = new LMBS_Matrix();
    this.viewProjMatrix = new LMBS_Matrix();

    this._lookAt = new LMBS_Vector3();
    this._up = new LMBS_Vector3(0, 1, 0);
    this._scalingWork1 = new LMBS_Vector3(0, 1, 0);
    this._scalingWork2 = new LMBS_Vector3(0, 1, 0);

    this._mode = LMBS_Camera.Mode.TargetTracking;   // カメラの姿勢指定モード
}

/**
 */
LMBS_Camera.prototype.setPosition = function(x, y, z) {
    this._positionX.setValue(x);
    this._positionY.setValue(y);
    this._positionZ.setValue(z);
}

/**
 */
LMBS_Camera.prototype.moveTo = function(x, y, z) {
    this._positionX.startAt(x, 20);
    this._positionY.startAt(y, 20);
    this._positionZ.startAt(z, 20);
}

/**
 */
LMBS_Camera.prototype.updateMatrix = function() {

    var fov = Math.PI / 3;

    if (this._mode == LMBS_Camera.Mode.TargetTracking) {
        var player = BattleManager.getUserOperatingActor();
        var enemy = player.getActionTargetBattlerObject();
        var hd = (enemy.position.x - player.position.x) / 2;
        this.moveTo(player.position.x + hd, 0, -Math.tan(fov) * Math.abs(hd));
        //this._position.x = player.position.x + hd;
        //this._position.z = -Math.tan(fov) * Math.abs(hd);
    }

    this._positionX.advanceTime(1);
    this._positionY.advanceTime(1);
    this._positionZ.advanceTime(1);

    this._position.x = this._positionX.getValue();
    this._position.y = this._positionY.getValue();
    this._position.z = this._positionZ.getValue();


    this._lookAt.x = this._position.x;
    this._lookAt.y = this._position.y;
    this._lookAt.z = 0;
    this.viewMatrix.makeLookAtLH(this._position, this._lookAt, this._up);
    this.projMatrix.makePerspectiveLH(fov, Graphics.width / Graphics.height, 1, 10000);
    // 乗算の順序に注意
    this.viewProjMatrix.multiply(this.viewMatrix, this.projMatrix);
}

/**
 *  @param  inPos {LMBS_Vector3}
 *  @param  outPos {LMBS_Vector3}
 */
LMBS_Camera.prototype.transformPosition = function(inPos, outPos) {
    outPos.transformCoord(inPos, this.viewProjMatrix);
    // transformCoord した outPos は -1～1 の範囲(スクリーン座標空間)となっている。
    // これをウィンドウ座標空間に直す。
    outPos.x = (outPos.x + 1) / 2 * Graphics.width;
    outPos.y = (outPos.y + 1) / 2 * Graphics.height;
    outPos.y *= -1;
    outPos.y += Graphics.height;
    //console.log(outPos.y );
}

/**
 *  @param  pos {LMBS_Vector3}
 */
LMBS_Camera.prototype.calcScale = function(pos) {
    // TODO: ちょっとものぐさ。視線に対して垂直にずらしたベクトルを使うのがベスト。
    // このままだと真上を見たときに拡大率 0 になるかも。まぁそんな使い方まずしないと思うけど。
    this._scalingWork1.set(pos.x, pos.y, pos.z);
    this._scalingWork2.set(pos.x, pos.y + 1, pos.z);

    var v1 = new LMBS_Vector3();
    var v2 = new LMBS_Vector3();
    this.transformPosition(this._scalingWork1, v1);
    this.transformPosition(this._scalingWork2, v2);
  //  this._scalingWork1.applyMatrix4(this.viewProjMatrix);
    //this._scalingWork2.applyMatrix4(this.viewProjMatrix);
    //return this._scalingWork2.y - this._scalingWork1.y;
    return Math.abs(v2.y - v1.y);
}


//=============================================================================
// LMBS_Object
//=============================================================================

function LMBS_Object() {
    this.initialize.apply(this, arguments);
}

LMBS_Object.prototype.constructor = LMBS_Object;


LMBS_Object.prototype.initialize = function(actorId) {
    LMBS_SceneGraph.addObject(this);
}

LMBS_Object.prototype.onUpdate = function() {
}

//=============================================================================
// LMBS_Battler
//=============================================================================
function LMBS_Battler() {
    this.initialize.apply(this, arguments);
}
LMBS_Battler.prototype = Object.create(LMBS_Object.prototype);
LMBS_Battler.prototype.constructor = LMBS_Battler;

LMBS_Battler.DIRECTION = {
  LEFT      : -1.0,
  RIGHT     :  1.0,
};

/**
 *  override
 */
LMBS_Battler.prototype.initialize = function() {
    LMBS_Object.prototype.initialize.call(this);
    //this.transform = new PIXI.Matrix();
    //this.transform.ty = 300;
    this.position = new LMBS_Vector3();           // 足元の位置 (ワールド空間)
    this.direction = LMBS_Battler.DIRECTION.LEFT;
    this._motionFrameCount = 0;
    this._visual = null;
    this._currentMotion = null;
    this._currentAction = null;

    this._forceGroup = 0;
    this._actionTarget = null;          // ターゲットとなっている LMBS_Battler

    this.changeAction(new LMBS_IdleAction());
};

/**
 *  (座標とサイズはワールド空間ベース)
 */
LMBS_Battler.prototype.setupComponents = function(x, y, width, height, forceGroup) {
    this._forceGroup = forceGroup;

    this._objectSize = new LMBS_Vector2(width, height); // ワールド空間内でのサイズ

    // 剛体
    this.mainBody = new LMBS_BoxBody(this._objectSize.x, this._objectSize.y, 1.0);
    this.mainBody.setPosition(x, y);
    // 初期位置として覚えておく
    this.position.x = x;
    this.position.y = y;
}

/**
 *
 */
LMBS_Battler.prototype.forceGroup = function() {
    return this._forceGroup;
}

/**
 *
 */
LMBS_Battler.prototype.setActionTargetBattlerObject = function(battlerObj) {
    this._actionTarget = battlerObj;
}

/**
 *
 */
LMBS_Battler.prototype.getActionTargetBattlerObject = function() {
    return this._actionTarget;
}

/**
 *  override
 */
LMBS_Battler.prototype.onUpdate = function() {
    LMBS_Object.prototype.onUpdate.call(this);

    var tx = this.mainBody.getPosition().x;
    var ty = this.mainBody.getPosition().y;
    this.position.x = tx;
    this.position.y = ty;

    this._visual.setPosition(this.position);
    this._visual.setDirection(this.direction);
    /*


    var v = new LMBS_Vector3(tx, ty, 0);
    var v2 = new LMBS_Vector3();
    LMBS_SceneGraph.camera.transformPosition(v, v2);
    var scale = LMBS_SceneGraph.camera.calcScale(v);
    this._visual.mainSprite.x = v2.x;//this.transform.tx;
    this._visual.mainSprite.y = v2.y;//this.transform.ty;


    // 向き
    var scaleX = -this.direction;
    this._visual.mainSprite.scale.x = scaleX;

    // 表示したいピクセルサイズで割ることで、ワールド座標系上のスケールを、ウィンドウ座標系上のスケールに変換する
    this._visual.mainSprite.scale.x = (scaleX * scale) / this._visual.mainSprite.width;
    this._visual.mainSprite.scale.y = scale / this._visual.mainSprite.height;
    */

    // アクションの更新
    if (this._currentAction != null) {
        this._currentAction.onUpdate();
    }
    // モーションの更新
    if (this._currentMotion != null) {
        this._currentMotion.update(this, this._motionFrameCount);
    }
    this._motionFrameCount++;
}

/**
 *
 */
LMBS_Battler.prototype.changeMotion = function(name) {
    // 適用中モーションと同じものなら何もしない
    if (this._currentMotion != null && this._currentMotion.name == name) {
        return;
    }
    this._currentMotion = LMBS_MotionManager.getMotion(name);
    this._motionFrameCount = 0;
}

/**
 *
 */
LMBS_Battler.prototype.changeAction = function(action) {
    // 適用中モーションと同じものなら何もしない
    if (this._currentAction != null && this._currentAction.name == name) {
        return;
    }
    this._currentAction = action;
    if (this._currentAction) {
        this._currentAction.battler = this;
        this._currentAction.onAttached();
    }
}


//=============================================================================
/**
 *
 * @class LMBS_Actor
 * @constructor
 */
function LMBS_Actor() { this.initialize.apply(this, arguments); }
LMBS_Actor.prototype = Object.create(LMBS_Battler.prototype);
LMBS_Actor.prototype.constructor = LMBS_Actor;

/**
 * constructor
 */
LMBS_Actor.prototype.initialize = function(actor) {
    LMBS_Battler.prototype.initialize.call(this);
    this._actor = actor;
    this.setupComponents(10 - this._actor.index() * 2, 0, 1, 1, LMBS_ForceGroup.Party);
    this._visual = new LMBS_AnimateSpliteVisual(this._actor.battlerName());
}

/**
 *  override
 */
LMBS_Actor.prototype.onUpdate = function() {
    LMBS_Battler.prototype.onUpdate.call(this);
    // ユーザー入力の更新
    if (this._currentAction != null &&
        $gameParty.members().indexOf(this._actor) == BattleManager.userOperationActorIndex) {
        this._currentAction.onUserInput();
    }
}

//=============================================================================
/**
 *
 * @class LMBS_Enemy
 * @constructor
 */
function LMBS_Enemy() { this.initialize.apply(this, arguments); }
LMBS_Enemy.prototype = Object.create(LMBS_Battler.prototype);
LMBS_Enemy.prototype.constructor = LMBS_Enemy;

/**
 * constructor
 *  @param  enemy {Game_Enemy}
 */
LMBS_Enemy.prototype.initialize = function(enemy) {
    LMBS_Battler.prototype.initialize.call(this);
    this._enemy = enemy;
    this.setupComponents(
      15 + this._enemy.screenX() * 10 / 816,  // 816 を 10 に
      15 - this._enemy.screenY() * 10 / 444,  // 反転。地面は0で、上がY+
      1, 1,
      LMBS_ForceGroup.Troop);
    this._visual = new LMBS_AnimateSpliteVisual("Actor1_2");
    // (0, 16)～(816,444)
  //  console.log(15 + this._enemy.screenX() * 15 / 816);
  //  console.log(15 - this._enemy.screenY() * 15 / 444);
}

/**
 *  override
 */
LMBS_Enemy.prototype.onUpdate = function() {
    LMBS_Battler.prototype.onUpdate.call(this);
}

//=============================================================================
// Game_BattlerBase
//=============================================================================

// 継承
//Game_BattlerBase.prototype = Object.create(Game_LMBSObject.prototype);

//=============================================================================
// Game_Battler
//=============================================================================

//-----------------------------------------------------------------------------
// initMembers
//-----------------------------------------------------------------------------
var _Game_Battler_prototype_initMembers = Game_Battler.prototype.initMembers;
Game_Battler.prototype.initMembers = function() {
    _Game_Battler_prototype_initMembers.call(this);
    //this.transform = new PIXI.Matrix();
  //  this.transform.tx = 200;
    //Game_LMBSObject.prototype.update.call(this);
}


//=============================================================================
// BattleManager
//=============================================================================

/**
 *  aliasing
 */
var _BattleManager_prototype_initMembers = BattleManager.initMembers;
BattleManager.initMembers = function() {
    _BattleManager_prototype_initMembers.call(this);
    this.userOperationActorIndex = 0; // ユーザー入力で操作するパーティ内のアクター番号
    this._battlerObjects = [];
    this._actorBattlerObjects = [];
    this._lmbsPhase = '';
    this.startMainPhase();
}

/**
 *  aliasing
 */
var _BattleManager_prototype_setup = BattleManager.setup;
BattleManager.setup = function(troopId, canEscape, canLose) {
    _BattleManager_prototype_setup.call(this, troopId, canEscape, canLose);
    this.userOperationActorIndex = 0;
}

/**
 *  aliasing
 */
var _BattleManager_startBattle = BattleManager.startBattle;
BattleManager.startBattle = function() {
    _BattleManager_startBattle.call(this);
    // パーティの Battelr
    $gameParty.members().forEach(function(actor) {
        var actorObj = new LMBS_Actor(actor);
        this._battlerObjects.push(actorObj);
        this._actorBattlerObjects.push(actorObj);
    }, this);
    // Enemy
    $gameTroop.members().forEach(function(enemy) {
        var enemyObj = new LMBS_Enemy(enemy);
        this._battlerObjects.push(enemyObj);
    }, this);

    // 初期ターゲット
    this._battlerObjects.forEach(function(obj) {
        var target = this.findNearBattlerObject(obj.position, ~obj.forceGroup());
        obj.setActionTargetBattlerObject(target);
    }, this);
}

/**
 *  プレイヤーが操作中の BattlerObject を返す
 */
BattleManager.getUserOperatingActor = function() {
    return this._actorBattlerObjects[this.userOperationActorIndex];
}

/**
 *  指定した勢力の中から、指定した位置に最も近い BattlerObject を探す
 *  @param  pos {LMBS_Vector3}  ワールド空間上の位置
 */
BattleManager.findNearBattlerObject = function(pos, forceGroup) {
    var obj = null;
    var d = 0;
    var list = this._battlerObjects;
    for (var i = 0; i < list.length; i++) {
        if ((list[i].forceGroup() & forceGroup) != 0) {
            var td = pos.distanceSq(list[i].position);
            // まだ見つけていなければ、指定勢力の最初に見つかったものとする。
            // 見つかっていれば obj に保持したものとの距離を比較。近ければ保持
            if (obj == null || td <= d) {
                obj = list[i];
                d = td;   // 距離を覚えておく
            }
        }
    }
    return obj;
}

/**
 *
 *  @param  pos {LMBS_Vector3}  ワールド空間上の位置
 *  @param  xDir {LMBS_Vector3}  探したい方向
 */
BattleManager.findSideBattlerObject = function(pos, xDir, forceGroup) {
    var obj = null;
    var d = 0;
    var list = this._battlerObjects;
    var candidates = [];
    // 同一勢力を候補として取り出す
    for (var i = 0; i < list.length; i++) {
        if ((list[i].forceGroup() & forceGroup) != 0) {
            candidates.push(list[i]);
        }
    }
    // X位置で昇順ソート
    candidates.sort(function(a, b){
        if ( a.position.x < b.position.x ) return -1;
        if ( a.position.x > b.position.x ) return 1;
        return 0;
    });
    // 右側に向かって調べたい
    if (xDir > 0) {
        for (var next = 0; next < candidates.length; next++) {
            if (pos.x < candidates[next].position.x) {
                return candidates[next];
            }
        }
        return candidates[0]; // 見つからなかったので、1順して一番左のモノ
    }
    // 左側に向かって調べたい
    else {
        for (var next = candidates.length - 1; next >= 0; next--) {
            if (candidates[next].position.x < pos.x) {
                return candidates[next];
            }
        }
        return candidates[candidates.length - 1]; // 見つからなかったので、1順して一番右のモノ
    }
    return null;
}

/**
 *
 */
BattleManager.update = function() {
    // 現在のフェーズで分岐
    switch (this._lmbsPhase) {
    case 'Main':
        this.updateMain();
        break;
    case 'TargetSelection':
        this.updateTargetSelection();
        break;
    }
}

/**
 *
 */
BattleManager.startMainPhase = function() {
    this._lmbsPhase = 'Main';
}

/**
 *
 */
BattleManager.startTargetSelectionPhase = function() {
    this._lmbsPhase = 'TargetSelection';
}

/**
 *
 */
BattleManager.getPhase = function() {
    return this._lmbsPhase;
}

/**
 *
 */
BattleManager.updateMain = function() {
    LMBS_SceneGraph.updateWorld();
    LMBS_SceneGraph.updateCamera();
}

/**
 *
 */
BattleManager.updateTargetSelection = function() {
    // カメラは移動したい
    LMBS_SceneGraph.updateCamera();
    if (Input.isTriggered('left')) {
        // ターゲット切り替え
        var player = this.getUserOperatingActor();
        var newTarget = this.findSideBattlerObject(player.getActionTargetBattlerObject().position, LMBS_Direction.Left, ~player.forceGroup());
        player.setActionTargetBattlerObject(newTarget);
    }
    else if (Input.isTriggered('right')) {
        // ターゲット切り替え
        var player = this.getUserOperatingActor();
        var newTarget = this.findSideBattlerObject(player.getActionTargetBattlerObject().position, LMBS_Direction.Right, ~player.forceGroup());
        player.setActionTargetBattlerObject(newTarget);
    }
}

//=============================================================================
// Scene_Boot
//=============================================================================
var _Scene_Boot_prototype_create = Scene_Boot.prototype.create;
Scene_Boot.prototype.create = function() {
    _Scene_Boot_prototype_create.call(this);
    LMBS_MotionManager.setup();
};

//=============================================================================
// Scene_Battle
//-----------------------------------------------------------------------------
//  SpriteSet は Scene クラスから SceneGraph へ送り込むのが自然だろう。
//=============================================================================

/**
 *  aliasing
 */
var _Scene_Battle_prototype_create = Scene_Battle.prototype.create;
Scene_Battle.prototype.create = function() {
    _Scene_Battle_prototype_create.call(this);
    // SceneGraph のスプライトはどこへ addChild するか指定する
    LMBS_SceneGraph.setup(this._spriteset);
};

/**
 *  aliasing
 */
var _Scene_Battle_prototype_createAllWindows = Scene_Battle.prototype.createAllWindows;
Scene_Battle.prototype.createAllWindows = function() {
    _Scene_Battle_prototype_createAllWindows.call(this);
    this.createTargetEnemyWindow();
}

/**
 *  aliasing
 */
var _Scene_Battle_prototype_update = Scene_Battle.prototype.update;
Scene_Battle.prototype.update = function() {
    _Scene_Battle_prototype_update.call(this);
    // フェーズごとの更新処理
    switch (BattleManager.getPhase()) {
    case 'Main':
        this.updateMainPhase();
        break;
    case 'TargetSelection':
        this.updateTargetSelectionPhase();
        break;
    }
}

/**
 *
 */
Scene_Battle.prototype.updateMainPhase = function() {
    // ターゲット選択キーが押されていたら選択フェーズへ
    if (Input.isPressed(LMBS_Settings.keySelectTarget)) {
        BattleManager.startTargetSelectionPhase();
        this._targetCursor.visible = true;
    }
};

/**
 *
 */
Scene_Battle.prototype.updateTargetSelectionPhase = function() {
    // キーが離されていたら Main に戻る
    if (!Input.isPressed(LMBS_Settings.keySelectTarget)) {
        BattleManager.startMainPhase();
        this._targetCursor.visible = false;
    }

    var player = BattleManager.getUserOperatingActor();
    target = player.getActionTargetBattlerObject();
    var pos = new LMBS_Vector3();
    pos.project(target.position, LMBS_SceneGraph.getMainCamera().viewProjMatrix, 0, 0, Graphics.boxWidth, Graphics.boxHeight, 0, 1);

    this._targetCursor.setPosition(pos.x, pos.y);
    this._targetCursor.update();
};

/**
 *
 */
Scene_Battle.prototype.createTargetEnemyWindow = function() {
    this._targetEnemyWindow = new LMBS_Window_TargetEnemy();
    this._targetEnemyWindow.visible = false;
    this.addWindow(this._targetEnemyWindow);
    this._targetCursor = new LMBS_TargetCursor();
    this._targetCursor.visible = false;
    this.addWindow(this._targetCursor);
};
